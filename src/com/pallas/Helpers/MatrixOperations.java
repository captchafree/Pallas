package com.pallas.Helpers;

import com.pallas.ImageLoading.Pixel;

public class MatrixOperations {

    /**
     * Returns a matrix with the horizontal components of the matrices pixels
     * @param pixels The matrix to calculate the gradient of
     * @return The matrix with the horizontal component of the gradient for each pixel
     */
    public static int[][] getGradientMatrixX(int[][] pixels) {
        int[][] result = new int[pixels.length][pixels[0].length];

        for(int i = 1; i < pixels.length-1; i++) {
            for(int j = 0; j < pixels[i].length; j++) {
                result[i][j] = (pixels[i+1][j] - pixels[i-1][j]) / 2;
            }
        }

        return result;
    }

    /**
     * Returns a matrix with the vertical components of the matrices pixels
     * @param pixels The matrix to calculate the gradient of
     * @return The matrix with the vertical component of the gradient for each pixel
     */
    public static int[][] getGradientMatrixY(int[][] pixels) {
        int[][] result = new int[pixels.length][pixels[0].length];

        for(int i = 0; i < pixels.length; i++) {
            for(int j = 1; j < pixels[i].length-1; j++) {
                result[i][j] = (pixels[i][j+1] - pixels[i][j-1]) / 2;
            }
        }

        return result;
    }

    /**
     * Calculates the cost matrix for a given 2D array.
     * @param matrix The matrix to generate the cost matrix for.
     * @return The cost matrix generated by the 2D array.
     */
    public static int[][] calculateCostMatrix(Pixel[][] matrix) {
        int[][] result = new int[matrix.length][matrix[0].length];

        //Create a copy of the matrix
        for(int i = 0 ; i < result.length; i++) {
            for (int j = 0; j < result[i].length; j++) {
                result[i][j] = matrix[i][j].getRedComponent();
            }
        }

        //Calculate the cost matrix with dynamic programming.
        for (int x = 0; x < result.length; x++) {
            for(int y = 0; y < result[x].length; y++) {
                if(y == 0) {
                    result[x][y] = matrix[x][y].getRedComponent();
                } else if(x == 0) {
                    result[x][y] = result[x][y] + Math.min(result[x][y-1], result[x+1][y-1]);
                } else if (x == result.length - 1) {
                    result[x][y] = result[x][y] + Math.min(result[x-1][y-1], result[x][y-1]);
                } else {
                    result[x][y] = result[x][y] + Math.min(Math.min(result[x-1][y-1], result[x][y-1]), result[x+1][y-1]);
                }
            }
        }

        return result;
    }
}
